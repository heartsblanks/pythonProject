pipeline {
    agent any

    environment {
        GIT_REPO = "https://<GITHUB_ENTERPRISE_URL>/<organization>/<repository>.git"
        GITHUB_TOKEN = credentials('github-token') // GitHub token stored in Jenkins credentials
    }

    stages {
        stage('Checkout Code') {
            steps {
                script {
                    echo "Checking out code from branch: ${env.BRANCH_NAME}"
                    checkout([
                        $class: 'GitSCM',
                        branches: [[name: "${env.BRANCH_NAME}"]],
                        userRemoteConfigs: [[
                            url: "${GIT_REPO}",
                            credentialsId: 'github-token'
                        ]]
                    ])
                }
            }
        }

        stage('Determine Tag Version') {
            steps {
                script {
                    // Fetch the latest tag and sanitize it
                    def latestTag = sh(script: "git describe --tags `git rev-list --tags --max-count=1` || echo 'v0.0.0'", returnStdout: true).trim()
                    echo "Latest tag fetched: ${latestTag}"

                    // Sanitize the tag to remove non-numeric parts (e.g., -DEV or -SNAPSHOT)
                    def sanitizedTag = latestTag.replaceAll(/-[a-zA-Z0-9.-]+$/, '')
                    echo "Sanitized tag: ${sanitizedTag}"

                    // Split sanitized version string into parts
                    def versionParts = sanitizedTag.replace('v', '').split('\\.')
                    def major = versionParts[0].toInteger()
                    def minor = versionParts[1].toInteger()
                    def patch = versionParts[2].toInteger()

                    // Determine version based on branch and build cause
                    if (env.BRANCH_NAME == 'master') {
                        if (env.CHANGE_ID != null && env.CHANGE_TARGET == 'master') {
                            // Pull request merged to master → Major version
                            echo "Pull request merged into master detected. Incrementing major version."
                            major += 1
                            minor = 0
                            patch = 0
                        } else if (currentBuild.getBuildCauses().any { it instanceof hudson.triggers.SCMTrigger$SCMTriggerCause }) {
                            // Commit to master → Minor version
                            echo "Commit to master detected. Incrementing minor version."
                            minor += 1
                        }
                    } else if (env.BRANCH_NAME.startsWith('hotfix/')) {
                        // Increment patch version for hotfix branches
                        echo "Hotfix branch detected. Incrementing patch version."
                        patch += 1
                    } else if (env.BRANCH_NAME.startsWith('feature/')) {
                        // Snapshot version for feature branches
                        echo "Feature branch detected. Using snapshot version."
                        env.RELEASE_VERSION = "v${major}.${minor}.${patch}-${env.BRANCH_NAME.replaceAll('/', '-')}-SNAPSHOT"
                        return
                    } else {
                        echo "Other branch detected. Using development version."
                        env.RELEASE_VERSION = "v${major}.${minor}.${patch}-DEV"
                        return
                    }

                    // Set the release version
                    env.RELEASE_VERSION = "v${major}.${minor}.${patch}"
                    echo "Determined release version: ${env.RELEASE_VERSION}"
                }
            }
        }

        stage('Tag and Push') {
            steps {
                script {
                    echo "Tagging branch ${env.BRANCH_NAME} with version ${env.RELEASE_VERSION}"

                    // Configure Git user
                    sh """
                        git config user.name "Jenkins CI"
                        git config user.email "jenkins@example.com"
                        git tag -a ${env.RELEASE_VERSION} -m "Tagging branch ${env.BRANCH_NAME} with version ${env.RELEASE_VERSION}"
                        git push origin ${env.RELEASE_VERSION}
                    """
                    echo "Tag ${env.RELEASE_VERSION} pushed for branch ${env.BRANCH_NAME}"
                }
            }
        }

        stage('Build and Test') {
            steps {
                echo "Running build and tests for branch: ${env.BRANCH_NAME}"
            }
        }
    }

    post {
        success {
            echo "Build succeeded for branch: ${env.BRANCH_NAME}"
        }
        failure {
            echo "Build failed for branch: ${env.BRANCH_NAME}"
        }
    }
}