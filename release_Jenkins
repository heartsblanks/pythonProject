pipeline {
    agent any

    environment {
        GIT_REPO = "git@github.com:your-organization/your-repository.git"
        MASTER_BRANCH = "master"
        FAILURE_RECIPIENTS = "dev1@example.com,dev2@example.com"
        SUCCESS_RECIPIENTS = "group1@example.com,group2@example.com"
        TEAMS_WEBHOOK = credentials('teams-webhook') // Jenkins credential for Teams webhook URL
        TEAMS_ICON_URL = "https://example.com/jenkins-icon.png" // Replace with your custom icon URL
        GITHUB_TOKEN = credentials('github-token') // Personal Access Token for GitHub API
    }

    stages {
        stage('Checkout Code') {
            steps {
                checkout([$class: 'GitSCM',
                          branches: [[name: "${env.BRANCH_NAME}"]],
                          userRemoteConfigs: [[url: "${env.GIT_REPO}"]]])
            }
        }

        stage('Determine Release Version') {
            steps {
                script {
                    def latestTag = sh(script: "git describe --tags `git rev-list --tags --max-count=1` || echo 'v0.0.0'", returnStdout: true).trim()
                    def versionParts = latestTag.replace('v', '').split('\\.')
                    def major = versionParts[0].toInteger()
                    def minor = versionParts[1].toInteger()
                    def patch = versionParts[2].toInteger()

                    if (env.BRANCH_NAME == MASTER_BRANCH) {
                        if (currentBuild.getBuildCauses().any { it instanceof hudson.triggers.SCMTrigger$SCMTriggerCause }) {
                            minor += 1 // Increment minor version for commits
                        } else {
                            major += 1 // Increment major version for push
                            minor = 0
                            patch = 0
                        }
                    } else if (env.BRANCH_NAME.startsWith("hotfix/")) {
                        patch += 1 // Increment patch version
                    } else if (env.BRANCH_NAME.startsWith("feature/")) {
                        env.RELEASE_VERSION = "v${major}.${minor}.${patch}-SNAPSHOT"
                        return
                    } else {
                        env.RELEASE_VERSION = "v${major}.${minor}.${patch}-DEV"
                        return
                    }

                    env.RELEASE_VERSION = "v${major}.${minor}.${patch}"
                    echo "Determined release version: ${env.RELEASE_VERSION}"
                }
            }
        }

        stage('Tag and Push') {
            when {
                expression { env.BRANCH_NAME == MASTER_BRANCH } // Only tag master branch
            }
            steps {
                script {
                    echo "Tagging repository with version ${env.RELEASE_VERSION}"
                    sh """
                        git config user.name "Jenkins"
                        git config user.email "jenkins@example.com"
                        git tag -a ${env.RELEASE_VERSION} -m "Release ${env.RELEASE_VERSION}"
                        git push origin ${env.RELEASE_VERSION}
                    """
                    echo "Tag pushed: ${env.RELEASE_VERSION}"
                }
            }
        }

        stage('Create GitHub Release') {
            when {
                expression { env.BRANCH_NAME == MASTER_BRANCH } // Only create release for master
            }
            steps {
                script {
                    echo "Creating GitHub release for version ${env.RELEASE_VERSION}"
                    def changelog = sh(script: "git log -1 --pretty=format:'%h %s (%an)'", returnStdout: true).trim()

                    httpRequest(
                        httpMode: 'POST',
                        url: "https://api.github.com/repos/your-organization/your-repository/releases",
                        customHeaders: [[name: 'Authorization', value: "Bearer ${env.GITHUB_TOKEN}"]],
                        contentType: 'APPLICATION_JSON',
                        requestBody: """
                            {
                                "tag_name": "${env.RELEASE_VERSION}",
                                "name": "Release ${env.RELEASE_VERSION}",
                                "body": "${changelog}",
                                "draft": false,
                                "prerelease": false
                            }
                        """
                    )
                    echo "GitHub release created for version ${env.RELEASE_VERSION}"
                }
            }
        }

        stage('Build and Test') {
            steps {
                echo "Running build and tests for branch: ${env.BRANCH_NAME}"
                echo "Release version: ${env.RELEASE_VERSION}"
            }
        }
    }

    post {
        success {
            script {
                def message = """
                    **Build Success** üéâ
                    - **Branch:** ${env.BRANCH_NAME}
                    - **Release Version:** ${env.RELEASE_VERSION}
                    - **Repository:** [${env.GIT_REPO}](<${env.GIT_REPO}>)
                """
                
                // Notify Teams
                sendTeamsNotification(message)

                // Notify email based on branch
                if (env.BRANCH_NAME == MASTER_BRANCH) {
                    emailext(
                        subject: "‚úÖ Success: Release Created - ${env.RELEASE_VERSION}",
                        body: message.replaceAll("\\*\\*", ""), // Remove markdown for plain email
                        mimeType: 'text/html',
                        to: "${SUCCESS_RECIPIENTS}"
                    )
                } else {
                    emailext(
                        subject: "‚úÖ Success: Build for Branch ${env.BRANCH_NAME}",
                        body: message.replaceAll("\\*\\*", ""),
                        mimeType: 'text/html',
                        to: "${FAILURE_RECIPIENTS}" // Notify developers for non-master branches
                    )
                }
            }
        }
        failure {
            script {
                def message = """
                    **Build Failure** ‚ùå
                    - **Branch:** ${env.BRANCH_NAME}
                    - **Repository:** [${env.GIT_REPO}](<${env.GIT_REPO}>)
                    - Check Jenkins logs for details.
                """

                // Notify Teams
                sendTeamsNotification(message)

                // Notify email for failures
                emailext(
                    subject: "‚ùå Failure: Build for Branch ${env.BRANCH_NAME}",
                    body: message.replaceAll("\\*\\*", ""),
                    mimeType: 'text/html',
                    to: "${FAILURE_RECIPIENTS}"
                )
            }
        }
    }
}